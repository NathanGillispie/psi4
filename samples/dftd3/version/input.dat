#! Exercises the various DFT-D corrections, both through python directly and through c++
#! all dft values updated to new BraggSlater radii

d3_engine = psi4.driver.EmpiricalDispersion(name_hint="b3lyp", level_hint="d3bj").engine

# S22-9, B3LYP

# S22-9 monomer, all fctl


# <<<  Part 1  >>>

molecule eeee {
C  -0.471925  -0.471925  -1.859111
C   0.471925   0.471925  -1.859111
H  -0.872422  -0.872422  -0.936125
H   0.872422   0.872422  -0.936125
H  -0.870464  -0.870464  -2.783308
H   0.870464   0.870464  -2.783308
--
0 1
C  -0.471925   0.471925   1.859111
C   0.471925  -0.471925   1.859111
H  -0.872422   0.872422   0.936125
H   0.872422  -0.872422   0.936125
H  -0.870464   0.870464   2.783308
H   0.870464  -0.870464   2.783308
units angstrom
}

mAuncp = eeee.extract_subsets(1)
mBuncp = eeee.extract_subsets(2)
mAcp = eeee.extract_subsets(1, 2)
mBcp = eeee.extract_subsets(2, 1)

eeee.update_geometry()
mAuncp.update_geometry()
mBuncp.update_geometry()
mAcp.update_geometry()
mBcp.update_geometry()

fctl = 'b3lyp'
der = 0
hasD3M = True
for dlvl in ['d3zero', 'd3bj', 'd3mzero', 'd3mbj']:
    # in contrast to classic dftd3, dftd3-python
    # * can't run d2
    # * runs d3 w/3-body corrections by default (psi4 aliases d3bj -> d3bj2b are valid here; d3bjatm to get w/3-body)
    E = eeee.run_sdftd3(fctl, dlvl, dertype=der)
    E = mAuncp.run_sdftd3(fctl, dlvl, dertype=der)
    E = mBcp.run_sdftd3(fctl, dlvl, dertype=der)

#hasD3M = False  # temporary until fctl released into superfunctionals list
# why have the hasD3M switch, you ask? why not just try catch throughout to
#   accomodate old and new dftd3 exe? the answer is we can't catch from c-side.

# <<<  Part 2  >>>

set basis sto-3g
set df_basis_scf cc-pvdz-ri
set scf_type df
set dft_radial_points 50  # use really bad grid for speed since all we want is the -D value
set dft_spherical_points 110
#set scf print 3  # will print dftd3 program output to psi4 output file

energy('b3lyp-d2', molecule=eeee)
# single test below fails for mysterious dft reasons

energy('b3lyp-d3', molecule=mAuncp)

energy('b3lyp-d3bj', molecule=mAcp)

energy('b3lyp-d3m', molecule=mBuncp)

energy('b3lyp-d3mbj', molecule=mBcp)


# <<<  Part 3  >>>
qeeee = qcdb.Molecule("""
C  -0.471925  -0.471925  -1.859111
C   0.471925   0.471925  -1.859111
H  -0.872422  -0.872422  -0.936125
H   0.872422   0.872422  -0.936125
H  -0.870464  -0.870464  -2.783308
H   0.870464   0.870464  -2.783308
--
0 1
C  -0.471925   0.471925   1.859111
C   0.471925  -0.471925   1.859111
H  -0.872422   0.872422   0.936125
H   0.872422  -0.872422   0.936125
H  -0.870464   0.870464   2.783308
H   0.870464  -0.870464   2.783308
units angstrom
""")

# note that it's extract_fragments on a qcdb.Mol, not extract_subsets
qmAuncp = qeeee.extract_fragments(1)
qmBuncp = qeeee.extract_fragments(2)
qmAcp = qeeee.extract_fragments(1, 2)
qmBcp = qeeee.extract_fragments(2, 1)

qeeee.update_geometry()
qmAuncp.update_geometry()
qmBuncp.update_geometry()
qmAcp.update_geometry()
qmBcp.update_geometry()

for dlvl in ['d3zero', 'd3bj', 'd3mzero', 'd3mbj']:
    E = qeeee.run_sdftd3(fctl, dlvl, dertype=der)
    E = qmAuncp.run_sdftd3(fctl, dlvl, dertype=der)
    E = qmBcp.run_sdftd3(fctl, dlvl, dertype=der)
for dlvl in ['d3zeroatm']:
    E = qeeee.run_sdftd3(fctl, dlvl, dertype=der)


# <<<  Part 4  >>>

set freeze_core false
for fl in ['blyp', 'b3lyp', 'b2plyp', 'bp86', 'pbe', 'pbe0', 'b97', 'wpbe']:
    energy(fl + '-d3mbj', molecule=mBuncp)
    energy(fl + '-d3mzero', molecule=mBuncp)

